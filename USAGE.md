# gg - Go 代码生成器完全使用指南

`gg` 是一个通用的 Go 代码生成器，提供接近原生 Go 语法的 API，让代码生成变得简单易懂。

## 目录

- [快速开始](#快速开始)
- [核心概念](#核心概念)
- [API 模式](#api-模式)
  - [Generator API（推荐）](#generator-api推荐)
  - [Group API（传统）](#group-api传统)
- [基础功能](#基础功能)
  - [包声明和注释](#包声明和注释)
  - [导入管理](#导入管理)
  - [函数定义](#函数定义)
  - [结构体](#结构体)
  - [接口](#接口)
  - [变量和常量](#变量和常量)
  - [类型定义](#类型定义)
- [高级特性](#高级特性)
  - [外部包引用](#外部包引用)
  - [函数调用](#函数调用)
  - [控制流](#控制流)
  - [字符串和字面量](#字符串和字面量)
  - [复合类型](#复合类型)
- [输出方法](#输出方法)
- [最佳实践](#最佳实践)
- [完整示例](#完整示例)

---

## 快速开始

### 安装

```bash
go get github.com/donutnomad/gg
```

### Hello World

```go
package main

import (
    "fmt"
    . "github.com/donutnomad/gg"
)

func main() {
    gen := New()
    gen.SetPackage("main")

    fmt := gen.P("fmt")

    gen.Body().NewFunction("main").AddBody(
        fmt.Call("Println", Lit("Hello, World!")),
    )

    fmt.Println(gen.String())
}
```

输出：
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

---

## 核心概念

### Node
`Node` 是 gg 中的基本单元，代表一个可渲染的代码元素。所有的代码结构（函数、结构体、语句等）都实现了 `Node` 接口。

### Group
`Group` 是节点的集合，用于组织多个代码元素。可以设置开始符、结束符和分隔符。

- `NewGroup()` - 创建默认 Group，元素间用换行分隔
- `NewInlineGroup()` - 创建单行 Group，元素间无分隔符，用于组合多个 Node 为单行代码

### Generator
`Generator` 是新版 API 的核心，提供完整的代码生成能力，包括：
- 包声明管理
- 自动 import 管理
- 外部包引用（PackageRef）
- 代码输出

---

## API 模式

### Generator API（推荐）

Generator API 是推荐的使用方式，它提供：
- 自动化的 import 管理
- 包引用自动解析别名冲突
- 标准库和第三方包自动分组
- 完整的文件生成支持

```go
gen := New()
gen.SetPackage("main")
gen.SetHeader("Code generated by tool. DO NOT EDIT.")

// 获取包引用
fmt := gen.P("fmt")
time := gen.P("time")

// 使用包引用
gen.Body().NewFunction("test").
    AddParameter("t", time.Type("Time")).
    AddBody(
        fmt.Call("Println", "test"),
    )

// 输出
gen.Write(os.Stdout)
gen.WriteFile("output.go")
output := gen.String()
```

### Group API（传统）

Group API 是传统的使用方式，适合简单场景：

```go
f := NewGroup()
f.AddPackage("main")
f.NewImport().AddPath("fmt")
f.NewFunction("main").AddBody(
    String(`fmt.Println("Hello")`),
)
fmt.Println(f.String())
```

---

## 基础功能

### 包声明和注释

#### 使用 Generator API

```go
gen := New()
gen.SetPackage("mypackage")
gen.SetHeader("Code generated by tool. DO NOT EDIT.")
```

生成：
```go
// Code generated by tool. DO NOT EDIT.
package mypackage
```

#### 使用 Group API

```go
g := NewGroup()
g.AddPackage("mypackage")
```

### 导入管理

#### 使用 Generator API（自动管理）

```go
gen := New()
gen.SetPackage("main")

// 通过 P() 方法注册包，自动添加到 import
fmt := gen.P("fmt")
context := gen.P("context")

// 使用包引用
gen.Body().NewFunction("test").
    AddParameter("ctx", context.Type("Context")).
    AddBody(
        fmt.Call("Println", Lit("test")),
    )
```

自动生成：
```go
package main

import (
    "context"
    "fmt"
)

func test(ctx context.Context) {
    fmt.Println("test")
}
```

#### 使用 Group API（手动管理）

```go
g := NewGroup()
g.NewImport().
    AddPath("context").              // import "context"
    AddDot("math").                  // import . "math"
    AddBlank("time").                // import _ "time"
    AddAlias("x", "testing")         // import x "testing"
```

生成：
```go
import (
    "context"
    . "math"
    _ "time"
    x "testing"
)
```

#### 添加空行和注释

```go
imp := Import()
imp.AddPath("fmt")
imp.AddLine()  // 空行
imp.AddLineComment("Third-party packages")
imp.AddPath("github.com/pkg/errors")
```

### 函数定义

#### 基本函数

```go
gen.Body().NewFunction("Add").
    AddParameter("a", "int").
    AddParameter("b", "int").
    AddResult("", "int").
    AddBody(
        Return(S("a + b")),
    )
```

生成：
```go
func Add(a int, b int) int {
    return a + b
}
```

#### 多返回值

```go
gen.Body().NewFunction("Divide").
    AddParameter("a", "int").
    AddParameter("b", "int").
    AddResult("", "int").
    AddResult("", "error").
    AddBody(
        S("if b == 0 {"),
        S("    return 0, errors.New(\"division by zero\")"),
        S("}"),
        S("return a / b, nil"),
    )
```

#### 命名返回值

```go
gen.Body().NewFunction("Parse").
    AddParameter("s", "string").
    AddResult("result", "int").
    AddResult("err", "error").
    AddBody(
        S("// implementation"),
    )
```

生成：
```go
func Parse(s string) (result int, err error) {
    // implementation
}
```

#### 方法（有接收者）

```go
gen.Body().NewFunction("String").
    WithReceiver("u", "*User").
    AddResult("", "string").
    AddBody(
        S("return u.Name"),
    )
```

生成：
```go
func (u *User) String() string {
    return u.Name
}
```

#### 立即调用函数

```go
gen.Body().NewFunction("").
    AddBody(
        S(`fmt.Println("executed")`),
    ).
    WithCall()
```

生成：
```go
func() {
    fmt.Println("executed")
}()
```

#### 快捷方法

```go
fn := Function("test")
fn.Param("x", "int")           // 等同于 AddParameter
fn.Return("error")             // 等同于 AddResult("", "error")
fn.Body(S("return nil"))       // 可以添加并返回 body Group

// Func 是 Function 的简写
fn := Func("test")
```

### 结构体

```go
gen.Body().NewStruct("User").
    AddField("ID", "int64").
    AddField("Name", "string").
    AddField("Email", "string").
    AddLineComment("Optional fields").
    AddLine().
    AddField("Age", "*int")
```

生成：
```go
type User struct {
    ID int64
    Name string
    Email string
    // Optional fields

    Age *int
}
```

### 接口

```go
gen.Body().NewInterface("Reader").
    NewFunction("Read").
        AddParameter("p", "[]byte").
        AddResult("n", "int").
        AddResult("err", "error")
```

生成：
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

#### 接口中添加注释

```go
iface := gen.Body().NewInterface("Service")
iface.AddLineComment("Core methods")
iface.NewFunction("Start").AddResult("", "error")
iface.AddLine()
iface.AddLineComment("Status methods")
iface.NewFunction("IsRunning").AddResult("", "bool")
```

### 变量和常量

#### 变量声明

```go
// 单个变量
gen.Body().NewVar().
    AddField("count", "0")

// 多个变量（带括号）
v := gen.Body().NewVar()
v.AddField("x", "10")
v.AddField("y", "20")

// 带类型的变量
gen.Body().NewVar().
    AddTypedField("name", "string", `"default"`)

// 仅声明（不初始化）
gen.Body().NewVar().
    AddDecl("buffer", "[]byte")
```

生成：
```go
var count = 0

var (
    x = 10
    y = 20
)

var name string = "default"

var buffer []byte
```

#### 常量声明

```go
// 单个常量
gen.Body().NewConst().
    AddField("Pi", "3.14159")

// 多个常量
c := gen.Body().NewConst()
c.AddField("MaxSize", "100")
c.AddLineComment("Status codes")
c.AddField("StatusOK", "200")
c.AddField("StatusError", "500")

// 带类型的常量
gen.Body().NewConst().
    AddTypedField("timeout", "time.Duration", "time.Second * 30")
```

### 类型定义

```go
// 类型别名（使用 =）
gen.Body().AddTypeAlias("UserID", "int64")

// 类型定义
gen.Body().AddType("Handler", "func(w http.ResponseWriter, r *http.Request)")
```

生成：
```go
type UserID = int64
type Handler func(w http.ResponseWriter, r *http.Request)
```

---

## 高级特性

### 外部包引用

Generator API 提供了强大的外部包引用功能（PackageRef）：

#### 基本用法

```go
gen := New()
gen.SetPackage("main")

// 注册包
types := gen.P("github.com/example/types")

// 使用类型
gen.Body().NewFunction("process").
    AddParameter("user", types.Type("User")).
    AddBody(S("// process user"))
```

#### 自动处理别名冲突

```go
// 两个包有相同的名称
types1 := gen.P("github.com/example/types")    // 别名: types
types2 := gen.P("github.com/other/types")      // 别名: types2

gen.Body().NewVar().
    AddField("u1", types1.Type("User")).
    AddField("u2", types2.Type("User"))
```

生成：
```go
import (
    "github.com/example/types"
    types2 "github.com/other/types"
)

var (
    u1 = types.User
    u2 = types2.User
)
```

#### 自定义别名

```go
ctx := gen.PAlias("context", "ctx")

gen.Body().NewFunction("handle").
    AddParameter("c", ctx.Type("Context"))
```

生成：
```go
import ctx "context"

func handle(c ctx.Context)
```

#### PackageRef 提供的方法

```go
pkg := gen.P("github.com/example/pkg")

// 类型引用
pkg.Type("User")              // pkg.User

// 标识符引用（常量、变量、函数）
pkg.Dot("DefaultTimeout")     // pkg.DefaultTimeout
pkg.Func("NewClient")         // pkg.NewClient

// 函数调用
pkg.Call("New", Lit("arg"))   // pkg.New("arg")

// 切片类型
pkg.Slice("User")             // []pkg.User

// 指针类型
pkg.Ptr("Config")             // *pkg.Config

// Map 类型
pkg.Map("string", "User")     // map[string]pkg.User
pkg.Map(other.Type("Key"), "Value")  // map[other.Key]pkg.Value

// Channel 类型
pkg.Chan("Event")             // chan pkg.Event
pkg.ChanRecv("Event")         // <-chan pkg.Event
pkg.ChanSend("Event")         // chan<- pkg.Event

// 泛型类型
pkg.Generic("List", "string")                    // pkg.List[string]
pkg.Generic("Map", "string", pkg.Type("User"))  // pkg.Map[string, pkg.User]
```

#### 完整示例

```go
gen := New()
gen.SetPackage("main")

types := gen.P("github.com/example/types")
db := gen.P("github.com/example/db")

gen.Body().NewFunction("CreateUser").
    AddParameter("conn", db.Type("Connection")).
    AddParameter("user", types.Ptr("User")).
    AddResult("", types.Type("UserID")).
    AddResult("", "error").
    AddBody(
        S("id, err := %s", db.Call("Insert", S("conn"), S("user"))),
        S("if err != nil {"),
        S("    return 0, err"),
        S("}"),
        Return(S("id"), S("nil")),
    )
```

### 函数调用

```go
// 简单调用
call := Call("Print").
    AddParameter(Lit("hello")).
    AddParameter(Lit(123))
// 生成: Print("hello", 123)

// 带所有者的调用
call := Call("Println").
    WithOwner("fmt").
    AddParameter(Lit("test"))
// 生成: fmt.Println("test")

// 链式调用
call := Call("Query").
    AddCall("Where", Lit("id = ?"), S("id")).
    AddCall("First", S("&user"))
// 生成: Query().Where("id = ?", id).First(&user)
```

#### ⚠️ 重要：PackageRef.Call() 与动态包名

当使用 `PackageRef.Call()` 时，为了确保 Merge 操作后包名能够动态更新，**不要**使用 `S()` 格式化字符串：

```go
// ❌ 错误方式 - 包名会被固化，Merge 后不会更新
tnDecl := S("tn := %s", gsqlPkg.Call("TableName", Lit("name")))

// ✅ 正确方式 - 使用 NewInlineGroup() 组合 Node
tnDecl := NewInlineGroup().Append(
    S("tn := "),
    gsqlPkg.Call("TableName", Lit("name")),
)
// 生成: tn := gsql.TableName("name")
// Merge 后自动变为: tn := gsql2.TableName("name")
```

**原因**：`S()` 函数使用 `fmt.Sprintf` 会立即将 Node 渲染成字符串，导致之后的 Merge 操作无法更新包名。

**解决方案**：使用 `NewInlineGroup()` 创建单行代码块，保持 Node 树的动态性。

**何时使用 NewInlineGroup()**：
- 需要在单行中组合多个 Node（如变量赋值语句）
- 使用 PackageRef 类型并且可能进行 Merge 操作
- 需要保持 AST 的动态性以便后续修改

**何时使用 NewGroup()**：
- 需要多行分隔的代码块
- 组织多个独立的语句或声明
- 不需要特别关注分隔符的场景

### 控制流

#### If 语句

```go
gen.Body().NewIf("err != nil").
    AddBody(
        S("log.Error(err)"),
        Return(S("nil"), S("err")),
    )
```

生成：
```go
if err != nil {
    log.Error(err)
    return nil, err
}
```

#### For 循环

```go
gen.Body().NewFor("i := 0; i < 10; i++").
    AddBody(
        S("fmt.Println(i)"),
    )

gen.Body().NewFor("range items").
    AddBody(
        S("process(item)"),
    )
```

#### Switch 语句

```go
sw := gen.Body().NewSwitch("status")

sw.NewCase(S("200")).
    AddBody(
        S("return handleSuccess()"),
    )

sw.NewCase(S("404")).
    AddBody(
        S("return handleNotFound()"),
    )

sw.NewDefault().
    AddBody(
        S("return handleError()"),
    )
```

生成：
```go
switch status {
case 200:
    return handleSuccess()
case 404:
    return handleNotFound()
default:
    return handleError()
}
```

### 字符串和字面量

#### String - 格式化字符串

```go
S("fmt.Println(%s)", `"hello"`)
S("x := %d", 42)

// 支持多行
S(`if err != nil {
    return err
}`)
```

#### Lit - 类型安全的字面量

```go
Lit("hello")          // "hello"
Lit(123)              // 123
Lit(3.14)             // 3.14
Lit(true)             // true
Lit(int64(100))       // int64(100)
Lit(float32(1.5))     // float32(1.5)
```

#### LineComment - 行注释

```go
gen.Body().AddLineComment("This is a comment")
gen.Body().AddLineComment("Format: %s", "value")
```

自动处理长注释：
```go
LineComment("This is a very long comment that will be automatically wrapped at 80 characters")
```

生成：
```go
// This is a very long comment that will be automatically wrapped at 80
// characters
```

#### Line - 空行

```go
gen.Body().AddLine()  // 添加空行
```

#### Template - 模板字符串

```go
type Data struct {
    Name string
    Age  int
}

gen.Body().Append(
    Template(Data{Name: "Alice", Age: 30}, `
func New() *User {
    return &User{
        Name: "{{.Name}}",
        Age:  {{.Age}},
    }
}
`))
```

### 复合类型

#### Slice - 切片字面量

`Slice()` 函数用于生成切片字面量，支持任何类型包括 PackageRef 引用的外部包类型。

**基本用法：**

```go
// 基本类型的切片
gen.Body().NewVar().AddField("numbers", Slice("int",
    Lit(1), Lit(2), Lit(3), Lit(4), Lit(5),
))
// 生成: var numbers = []int{1, 2, 3, 4, 5}

// 字符串切片
gen.Body().NewVar().AddField("fruits", Slice("string",
    Lit("apple"),
    Lit("banana"),
    Lit("cherry"),
))
// 生成: var fruits = []string{"apple", "banana", "cherry"}

// 使用 PackageRef 的切片
types := gen.P("github.com/example/types")
gen.Body().NewVar().AddField("users", Slice(types.Type("User"),
    S("types.User{ID: 1, Name: \"Alice\"}"),
    S("types.User{ID: 2, Name: \"Bob\"}"),
))
// 生成: var users = []types.User{types.User{ID: 1, Name: "Alice"}, types.User{ID: 2, Name: "Bob"}}

// 指针类型的切片
gen.Body().NewVar().AddField("configs", Slice(types.Ptr("Config"),
    S("&types.Config{Name: \"dev\"}"),
    S("&types.Config{Name: \"prod\"}"),
    S("nil"),
))
// 生成: var configs = []*types.Config{&types.Config{Name: "dev"}, &types.Config{Name: "prod"}, nil}
```

**多行格式：**

使用 `MultiLine()` 方法可以让每个元素独占一行，提高可读性：

**注意**：如果元素列表为空，即使调用了 `MultiLine()`，也会渲染为单行格式 `[]Type{}`。

```go
gen.Body().NewVar().AddField("users", Slice("User",
    S("User{ID: 1, Name: \"Alice\"}"),
    S("User{ID: 2, Name: \"Bob\"}"),
    S("User{ID: 3, Name: \"Charlie\"}"),
).MultiLine())

// 生成:
// var users = []User{
// User{ID: 1, Name: "Alice"},
// User{ID: 2, Name: "Bob"},
// User{ID: 3, Name: "Charlie"},
// }
```

**动态添加元素：**

```go
// 创建空切片后动态添加元素
s := Slice("string")
items := []string{"one", "two", "three", "four"}
for _, item := range items {
    s.AddElement(Lit(item))
}
gen.Body().NewVar().AddField("dynamicSlice", s)
// 生成: var dynamicSlice = []string{"one", "two", "three", "four"}
```

**在函数中使用：**

```go
types := gen.P("github.com/example/types")

// 作为返回类型
gen.Body().NewFunction("GetDefaultUsers").
    Return(types.Slice("User")).
    AddBody(
        Return(Slice(types.Type("User"),
            S("types.User{ID: 1, Name: \"User1\"}"),
            S("types.User{ID: 2, Name: \"User2\"}"),
        )),
    )
// 生成:
// func GetDefaultUsers() []types.User {
//     return []types.User{types.User{ID: 1, Name: "User1"}, types.User{ID: 2, Name: "User2"}}
// }

// 作为参数类型
gen.Body().NewFunction("ProcessItems").
    AddParameter("items", types.Slice("Item")).
    AddResult("", "error").
    AddBody(
        S("// process items"),
        Return(S("nil")),
    )
// 生成:
// func ProcessItems(items []types.Item) error {
//     // process items
//     return nil
// }
```

#### Array - 数组字面量

`Array()` 函数用于生成固定大小的数组字面量，同样支持 `MultiLine()` 方法。

```go
// 基本类型数组
gen.Body().NewVar().AddField("numbers", Array(5, "int",
    Lit(1), Lit(2), Lit(3), Lit(4), Lit(5),
))
// 生成: var numbers = [5]int{1, 2, 3, 4, 5}

// 多维数组（数组的数组）
gen.Body().NewVar().AddField("matrix", Array(3, "[]int",
    Slice("int", Lit(1), Lit(2), Lit(3)),
    Slice("int", Lit(4), Lit(5), Lit(6)),
    Slice("int", Lit(7), Lit(8), Lit(9)),
))
// 生成: var matrix = [3][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}

// 多行格式
gen.Body().NewVar().AddField("matrix", Array(3, "[]int",
    Slice("int", Lit(1), Lit(2), Lit(3)),
    Slice("int", Lit(4), Lit(5), Lit(6)),
    Slice("int", Lit(7), Lit(8), Lit(9)),
).MultiLine())
// 生成:
// var matrix = [3][]int{
// []int{1, 2, 3},
// []int{4, 5, 6},
// []int{7, 8, 9},
// }

// 使用 PackageRef 的数组
types := gen.P("github.com/example/types")
gen.Body().NewVar().AddField("configs", Array(3, types.Ptr("Config"),
    S("&types.Config{Name: \"dev\"}"),
    S("&types.Config{Name: \"staging\"}"),
    S("&types.Config{Name: \"prod\"}"),
))
// 生成: var configs = [3]*types.Config{&types.Config{Name: "dev"}, ...}
```

**动态添加元素：**

```go
a := Array(5, "string")
a.AddElement(Lit("a"), Lit("b"), Lit("c"))
a.AddElement(Lit("d"), Lit("e"))
// 生成: [5]string{"a", "b", "c", "d", "e"}
```

#### Value - 复合字面量

`Value()` 函数用于生成复合字面量，支持结构体和自定义类型（如类型别名）。

**结构体字面量（使用 AddField）：**

```go
v := Value("User")
v.AddField("ID", "1")
v.AddField("Name", Lit("Alice"))
v.AddField("Age", "30")

// 生成: User{ID: 1, Name: "Alice", Age: 30}
```

**自定义类型字面量（使用 AddElement）：**

对于自定义类型别名（如 `type UserList []User`），应该使用 `Value().AddElement()` 而不是 `Slice()`：

```go
// 定义: type UserList []User
gen.Body().NewVar().AddField("users",
    Value("UserList").AddElement(
        S("User{ID: 1, Name: \"Alice\"}"),
        S("User{ID: 2, Name: \"Bob\"}"),
    ),
)
// 生成: var users = UserList{User{ID: 1, Name: "Alice"}, User{ID: 2, Name: "Bob"}}

// 定义: type IntList []int
gen.Body().NewVar().AddField("numbers",
    Value("IntList").AddElement(
        Lit(1), Lit(2), Lit(3), Lit(4), Lit(5),
    ),
)
// 生成: var numbers = IntList{1, 2, 3, 4, 5}
```

**使用 PackageRef 的自定义类型：**

```go
types := gen.P("github.com/example/types")

// 外部包的自定义类型
gen.Body().NewVar().AddField("users",
    Value(types.Type("UserList")).AddElement(
        S("types.User{ID: 1}"),
        S("types.User{ID: 2}"),
    ),
)
// 生成: var users = types.UserList{types.User{ID: 1}, types.User{ID: 2}}
```

**Map 类型别名：**

```go
// 定义: type StringMap map[string]string
v := Value("StringMap")
v.AddField(Lit("key1"), Lit("value1"))
v.AddField(Lit("key2"), Lit("value2"))
// 生成: StringMap{"key1": "value1", "key2": "value2"}
```

**⚠️ 重要区别：**

- 使用 `Slice()`：生成**匿名切片类型**的字面量 → `[]User{...}`
- 使用 `Value().AddElement()`：生成**自定义类型**的字面量 → `UserList{...}`

```go
// 场景 1: 匿名切片类型
gen.Body().NewVar().AddField("users", Slice("User", ...))
// 生成: var users = []User{...}

// 场景 2: 自定义类型别名（type UserList []User）
gen.Body().NewVar().AddField("users", Value("UserList").AddElement(...))
// 生成: var users = UserList{...}
```

#### Return 语句

```go
Return(S("result"), S("nil"))
// 生成: return result, nil

Return(S("User{Name: name}"))
// 生成: return User{Name: name}
```

#### Defer 语句

```go
gen.Body().Append(
    Defer(S("file.Close()")),
)
// 生成: defer file.Close()
```

#### Continue 语句

```go
gen.Body().NewFor("range items").
    AddBody(
        S("if shouldSkip(item) {"),
        Continue(),
        S("}"),
    )
```

---

## 输出方法

### Generator 输出

```go
gen := New()

// 输出为字符串
output := gen.String()

// 输出为字节数组
bytes := gen.Bytes()

// 写入 Writer
gen.Write(os.Stdout)

// 写入文件（完整内容，包含 package 和 import）
err := gen.WriteFile("output.go")

// 追加到文件（仅 body，不含 package 和 import）
err := gen.AppendFile("existing.go")
```

### Group 输出（传统）

```go
g := NewGroup()

// 输出为字符串
output := g.String()

// 写入 Writer
g.Write(os.Stdout)

// 写入文件
err := g.WriteFile("output.go")

// 追加到文件
err := g.AppendFile("existing.go")
```

---

## 最佳实践

### 1. 使用 Generator API

优先使用 `Generator` API 而不是直接使用 `Group`：
- 自动管理 import
- 自动处理别名冲突
- 更清晰的代码结构

```go
// ✅ 推荐
gen := New()
gen.SetPackage("main")
fmt := gen.P("fmt")
gen.Body().NewFunction("main").AddBody(
    fmt.Call("Println", Lit("hello")),
)

// ❌ 不推荐（除非只生成代码片段）
g := NewGroup()
g.AddString(`fmt.Println("hello")`)
```

### 2. 使用包引用而非字符串拼接

```go
// ✅ 推荐
types := gen.P("github.com/example/types")
gen.Body().NewVar().AddField("u", types.Type("User"))

// ❌ 不推荐
gen.Body().NewVar().AddField("u", S("types.User"))
```

### 3. 使用 Lit() 生成字面量

```go
// ✅ 推荐 - 类型安全
Call("Print").AddParameter(Lit("hello"), Lit(123))

// ❌ 不推荐 - 容易出错
Call("Print").AddParameter(S(`"hello"`), S("123"))
```

### 4. 组织代码结构

```go
gen := New()
gen.SetPackage("myapp")
gen.SetHeader("Code generated by tool. DO NOT EDIT.")

// 定义类型
types := gen.P("github.com/example/types")

// 添加常量
c := gen.Body().NewConst()
c.AddField("Version", Lit("1.0.0"))

// 添加结构体
gen.Body().NewStruct("Config").
    AddField("Host", "string").
    AddField("Port", "int")

// 添加函数
gen.Body().NewFunction("New").
    Return(types.Ptr("Config")).
    AddBody(
        Return(S("&Config{}")),
    )
```

### 5. 使用辅助函数

将重复的代码生成逻辑封装为辅助函数：

```go
func generateGetter(g *Generator, structName, fieldName, fieldType string) {
    methodName := "Get" + fieldName
    g.Body().NewFunction(methodName).
        WithReceiver("s", "*"+structName).
        Return(fieldType).
        AddBody(
            Return(S("s." + fieldName)),
        )
}

// 使用
generateGetter(gen, "User", "Name", "string")
generateGetter(gen, "User", "Age", "int")
```

### 6. 标准库和第三方包自动分组

Generator 会自动将导入分为标准库和第三方两组，并用空行分隔：

```go
fmt := gen.P("fmt")
time := gen.P("time")
types := gen.P("github.com/example/types")
```

自动生成：
```go
import (
    "fmt"
    "time"

    "github.com/example/types"
)
```

### 7. 合并多个 Generator

```go
gen1 := New()
gen1.SetPackage("main")
// ... 添加一些代码

gen2 := New()
// ... 添加另一些代码

// 合并 gen2 到 gen1
gen1.Merge(gen2)
```

---

## 完整示例

### 示例 1：生成 RESTful API 处理器

```go
package main

import (
    "fmt"
    "os"

    . "github.com/donutnomad/gg"
)

func main() {
    gen := New()
    gen.SetPackage("handlers")
    gen.SetHeader("Code generated by api-gen. DO NOT EDIT.")

    // 引用外部包
    http := gen.P("net/http")
    json := gen.P("encoding/json")
    types := gen.P("github.com/example/types")

    // 生成处理器函数
    fn := gen.Body().NewFunction("HandleUser")
    fn.AddParameter("w", http.Type("ResponseWriter"))
    fn.AddParameter("r", http.Ptr("Request"))
    fn.AddBody(
        S("var user %s", types.Type("User")),
        S(""),
        S("if err := %s; err != nil {",
            json.Call("NewDecoder", S("r.Body")).String() + ".Decode(&user)",
        ),
        S("    %s", http.Call("Error", S("w"), Lit("invalid request"), S("http.StatusBadRequest"))),
        S("    return"),
        S("}"),
        S(""),
        LineComment("Process user"),
        S("// TODO: implement business logic"),
        S(""),
        S("w.WriteHeader(http.StatusOK)"),
        S("%s", json.Call("NewEncoder", S("w")).String() + ".Encode(user)"),
    )

    // 输出到文件
    if err := gen.WriteFile("handlers/user.go"); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

### 示例 2：生成数据模型

```go
func generateModel(entityName string, fields map[string]string) string {
    gen := New()
    gen.SetPackage("models")

    time := gen.P("time")

    // 生成结构体
    st := gen.Body().NewStruct(entityName)
    st.AddField("ID", "int64")
    st.AddField("CreatedAt", time.Type("Time"))
    st.AddField("UpdatedAt", time.Type("Time"))
    st.AddLine()

    for field, typ := range fields {
        st.AddField(field, typ)
    }

    // 生成 TableName 方法
    gen.Body().NewFunction("TableName").
        WithReceiver("", entityName).
        Return("string").
        AddBody(
            Return(Lit(strings.ToLower(entityName) + "s")),
        )

    return gen.String()
}

// 使用
output := generateModel("User", map[string]string{
    "Name":  "string",
    "Email": "string",
    "Age":   "int",
})
```

### 示例 3：生成接口和实现

```go
func generateService(serviceName string, methods []Method) {
    gen := New()
    gen.SetPackage("services")

    context := gen.P("context")

    // 生成接口
    iface := gen.Body().NewInterface(serviceName)
    for _, m := range methods {
        sig := iface.NewFunction(m.Name)
        sig.AddParameter("ctx", context.Type("Context"))
        for _, p := range m.Params {
            sig.AddParameter(p.Name, p.Type)
        }
        for _, r := range m.Results {
            sig.AddResult(r.Name, r.Type)
        }
    }

    gen.Body().AddLine()

    // 生成实现
    implName := serviceName + "Impl"
    gen.Body().NewStruct(implName).
        AddLineComment("TODO: add fields")

    // 生成构造函数
    gen.Body().NewFunction("New" + serviceName).
        Return(serviceName).
        AddBody(
            Return(S("&%s{}", implName)),
        )

    // 为每个方法生成实现
    for _, m := range methods {
        fn := gen.Body().NewFunction(m.Name)
        fn.WithReceiver("s", "*"+implName)
        fn.AddParameter("ctx", context.Type("Context"))
        for _, p := range m.Params {
            fn.AddParameter(p.Name, p.Type)
        }
        for _, r := range m.Results {
            fn.AddResult(r.Name, r.Type)
        }
        fn.AddBody(
            LineComment("TODO: implement " + m.Name),
            S("panic(\"not implemented\")"),
        )
    }

    gen.WriteFile("services/" + strings.ToLower(serviceName) + ".go")
}
```

### 示例 4：使用模板生成复杂代码

```go
type ServiceData struct {
    Name    string
    Methods []string
}

gen := New()
gen.SetPackage("services")

data := ServiceData{
    Name:    "UserService",
    Methods: []string{"Create", "Get", "Update", "Delete"},
}

// 使用模板生成
gen.Body().Append(
    Template(data, `
type {{.Name}} interface {
    {{range .Methods}}
    {{.}}(ctx context.Context) error
    {{end}}
}
`))

fmt.Println(gen.String())
```

### 示例 5：生成数组和切片

```go
package main

import (
    "fmt"
    . "github.com/donutnomad/gg"
)

func main() {
    gen := New()
    gen.SetPackage("example")
    gen.SetHeader("Code generated by example. DO NOT EDIT.")

    // 引用外部包
    types := gen.P("github.com/example/types")
    fmtPkg := gen.P("fmt")

    // 1. 基本类型的切片
    gen.Body().NewVar().AddField("numbers", Slice("int",
        Lit(1), Lit(2), Lit(3), Lit(4), Lit(5),
    ))

    // 2. 使用 PackageRef 的切片
    gen.Body().NewVar().AddField("users", Slice(types.Type("User"),
        S("types.User{ID: 1, Name: \"Alice\"}"),
        S("types.User{ID: 2, Name: \"Bob\"}"),
    ))

    // 3. 指针类型的切片
    gen.Body().NewVar().AddField("configs", Slice(types.Ptr("Config"),
        S("&types.Config{Name: \"dev\"}"),
        S("&types.Config{Name: \"prod\"}"),
    ))

    // 4. 固定大小数组
    gen.Body().NewVar().AddField("matrix", Array(3, "[]int",
        Slice("int", Lit(1), Lit(2), Lit(3)),
        Slice("int", Lit(4), Lit(5), Lit(6)),
        Slice("int", Lit(7), Lit(8), Lit(9)),
    ))

    // 5. 动态添加元素
    s := Slice("string")
    items := []string{"one", "two", "three", "four"}
    for _, item := range items {
        s.AddElement(Lit(item))
    }
    gen.Body().NewVar().AddField("dynamicSlice", s)

    // 6. 在函数中使用
    gen.Body().NewFunction("GetDefaultUsers").
        Return(types.Slice("User")).
        AddBody(
            Return(Slice(types.Type("User"),
                S("types.User{ID: 1, Name: \"User1\"}"),
                S("types.User{ID: 2, Name: \"User2\"}"),
            )),
        )

    // 7. 作为函数参数
    gen.Body().NewFunction("ProcessItems").
        AddParameter("items", types.Slice("Item")).
        AddResult("", "error").
        AddBody(
            S("for _, item := range items {"),
            S("    %s", fmtPkg.Call("Println", S("item"))),
            S("}"),
            Return(S("nil")),
        )

    fmt.Println(gen.String())
}
```

输出（格式化后）：
```go
// Code generated by example. DO NOT EDIT.
package example

import (
    "fmt"

    "github.com/example/types"
)

var numbers = []int{1, 2, 3, 4, 5}
var users = []types.User{types.User{ID: 1, Name: "Alice"}, types.User{ID: 2, Name: "Bob"}}
var configs = []*types.Config{&types.Config{Name: "dev"}, &types.Config{Name: "prod"}}
var matrix = [3][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}
var dynamicSlice = []string{"one", "two", "three", "four"}

func GetDefaultUsers() []types.User {
    return []types.User{types.User{ID: 1, Name: "User1"}, types.User{ID: 2, Name: "User2"}}
}

func ProcessItems(items []types.Item) error {
    for _, item := range items {
        fmt.Println(item)
    }
    return nil
}
```

---

## 性能提示

1. **使用对象池**：gg 内部使用 buffer pool 来减少内存分配
2. **批量操作**：尽可能在单次操作中添加多个元素
3. **避免频繁转换**：不要频繁调用 `String()` 方法，在最后才转换

---

## 常见问题

### Q: Generator 和 Group 有什么区别？
A: Generator 是新的推荐 API，提供自动 import 管理和包引用功能。Group 是传统 API，适合生成简单代码片段。

### Q: 如何处理包名冲突？
A: Generator 会自动处理。第一个包用原名，后续同名包会添加数字后缀（types, types2, types3...）

### Q: 可以在生成的代码中使用当前包的类型吗？
A: 可以直接使用字符串，无需通过 P() 注册：
```go
gen.Body().NewVar().AddField("user", "User")  // 当前包的 User 类型
```

### Q: 如何生成泛型代码？
A: 使用 `Generic()` 方法：
```go
types := gen.P("github.com/example/types")
types.Generic("List", "string")  // types.List[string]
```

### Q: 支持 Go 1.18+ 的新特性吗？
A: 是的，支持泛型、类型参数等 Go 1.18+ 特性。

---

## 相关资源

- **GitHub**: https://github.com/donutnomad/gg
- **Go Doc**: https://pkg.go.dev/github.com/donutnomad/gg
- **灵感来源**: [dave/jennifer](https://github.com/dave/jennifer)

## 贡献

欢迎提交 Issue 和 Pull Request！

## 许可证

Apache License 2.0
