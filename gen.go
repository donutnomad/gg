package gg

import (
	"fmt"
	"io"
	"os"
	"sort"
)

// Generator is the main entry point for code generation.
// It manages packages, imports, and provides methods for generating Go code.
type Generator struct {
	g *Group

	// Package management
	packageName     string                 // current package name (e.g., "main")
	packages        map[string]*PackageRef // importPath -> PackageRef
	aliasToPath     map[string]string      // alias -> importPath (for conflict detection)
	registeredPaths []string               // ordered list of import paths for deterministic output

	// Header comment (appears before package declaration)
	headerComment string
}

// New will create a new generator which hold the group reference.
func New() *Generator {
	return &Generator{
		g:           NewGroup(),
		packages:    make(map[string]*PackageRef),
		aliasToPath: make(map[string]string),
	}
}

// SetPackage sets the package name for the generated file.
func (g *Generator) SetPackage(name string) *Generator {
	g.packageName = name
	return g
}

// SetHeader sets a header comment that appears before the package declaration.
// Typically used for "Code generated by X. DO NOT EDIT." comments.
func (g *Generator) SetHeader(format string, args ...any) *Generator {
	g.headerComment = fmt.Sprintf(format, args...)
	return g
}

// P returns a PackageRef for the given import path.
// If the package was already registered, it returns the existing reference.
// Otherwise, it creates a new reference with an automatically resolved alias.
//
// Example:
//
//	types := gen.P("github.com/example/types")
//	other := gen.P("github.com/other/types")  // auto-aliased to "types2"
//	types.Type("User")  // => types.User
//	other.Type("User")  // => types2.User
func (g *Generator) P(importPath string) *PackageRef {
	// Return existing package reference if already registered
	if pkg, ok := g.packages[importPath]; ok {
		return pkg
	}

	// Build set of existing aliases
	existingAliases := make(map[string]bool)
	for alias := range g.aliasToPath {
		existingAliases[alias] = true
	}

	// Resolve alias (handles conflicts automatically)
	alias := resolvePackageAlias(importPath, existingAliases)

	// Create and register the package reference
	pkg := &PackageRef{
		importPath: importPath,
		alias:      alias,
		gen:        g,
	}
	g.packages[importPath] = pkg
	g.aliasToPath[alias] = importPath
	g.registeredPaths = append(g.registeredPaths, importPath)

	return pkg
}

// PAlias returns a PackageRef with a specific alias.
// Use this when you want to control the alias name explicitly.
//
// Example:
//
//	ctx := gen.PAlias("context", "ctx")
//	ctx.Type("Context")  // => ctx.Context
func (g *Generator) PAlias(importPath, alias string) *PackageRef {
	// Check if already registered with different alias
	if pkg, ok := g.packages[importPath]; ok {
		if pkg.alias != alias {
			// Update alias if different
			delete(g.aliasToPath, pkg.alias)
			pkg.alias = alias
			g.aliasToPath[alias] = importPath
		}
		return pkg
	}

	// Check for alias conflict
	if existingPath, ok := g.aliasToPath[alias]; ok && existingPath != importPath {
		panic(fmt.Sprintf("alias %q already used for package %q, cannot use for %q", alias, existingPath, importPath))
	}

	// Create and register the package reference
	pkg := &PackageRef{
		importPath: importPath,
		alias:      alias,
		gen:        g,
	}
	g.packages[importPath] = pkg
	g.aliasToPath[alias] = importPath
	g.registeredPaths = append(g.registeredPaths, importPath)

	return pkg
}

// Imports returns all registered import paths.
func (g *Generator) Imports() []string {
	return g.registeredPaths
}

// buildImportBlock creates the import block from registered packages.
func (g *Generator) buildImportBlock() *iimport {
	if len(g.packages) == 0 {
		return nil
	}

	imp := Import()

	// Sort imports for deterministic output
	paths := make([]string, 0, len(g.packages))
	for path := range g.packages {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	// Group imports: standard library first, then third-party
	var stdLib, thirdParty []string
	for _, p := range paths {
		if isStdLib(p) {
			stdLib = append(stdLib, p)
		} else {
			thirdParty = append(thirdParty, p)
		}
	}

	// Add standard library imports
	for _, p := range stdLib {
		pkg := g.packages[p]
		baseName := resolvePackageAlias(p, nil)
		if pkg.alias != baseName {
			imp.AddAlias(p, pkg.alias)
		} else {
			imp.AddPath(p)
		}
	}

	// Add blank line between groups if both exist
	if len(stdLib) > 0 && len(thirdParty) > 0 {
		imp.AddLine()
	}

	// Add third-party imports
	for _, p := range thirdParty {
		pkg := g.packages[p]
		baseName := resolvePackageAlias(p, nil)
		if pkg.alias != baseName {
			imp.AddAlias(p, pkg.alias)
		} else {
			imp.AddPath(p)
		}
	}

	return imp
}

// isStdLib checks if an import path is from the standard library.
func isStdLib(importPath string) bool {
	// Standard library packages don't contain dots in the first segment
	for i, r := range importPath {
		if r == '/' {
			return true // No dot before first slash = stdlib
		}
		if r == '.' {
			return false // Found dot before slash = third-party
		}
		if i > 20 {
			break // Safety limit
		}
	}
	return true // Short path without slash = likely stdlib
}

func (g *Generator) NewGroup() (ng *Group) {
	ng = NewGroup()
	g.g.append(ng)
	return ng
}

// render writes the complete generated code including package declaration and imports.
func (g *Generator) render(w io.Writer) {
	// Write header comment (before package declaration)
	if g.headerComment != "" {
		writeStringF(w, "// %s\n", g.headerComment)
	}

	// Write package declaration
	if g.packageName != "" {
		writeStringF(w, "package %s\n\n", g.packageName)
	}

	// Write import block
	if imp := g.buildImportBlock(); imp != nil {
		imp.render(w)
		writeString(w, "\n\n")
	}

	// Write body
	g.g.render(w)
}

// Write will write the complete generated code into the given writer.
// This includes the package declaration and automatically generated imports.
func (g *Generator) Write(w io.Writer) {
	g.render(w)
}

// WriteFile will write the complete generated code into the given path.
func (g *Generator) WriteFile(path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file %s: %s", path, err)
	}
	defer file.Close()
	g.render(file)
	return nil
}

// AppendFile will append the group after the given path.
// Note: This only appends the body, not package/imports.
func (g *Generator) AppendFile(path string) error {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("create file %s: %s", path, err)
	}
	defer file.Close()
	g.g.render(file)
	return nil
}

// String returns the complete generated code as a string.
func (g *Generator) String() string {
	buf := pool.Get()
	defer buf.Free()
	g.render(buf)
	return buf.String()
}

// Body returns the body group for adding code elements.
// This provides direct access to the internal group for adding functions, structs, etc.
func (g *Generator) Body() *Group {
	return g.g
}

// Bytes returns the complete generated code as bytes.
func (g *Generator) Bytes() []byte {
	buf := pool.Get()
	defer buf.Free()
	g.render(buf)
	return buf.Bytes()
}

// Merge merges another Generator's body and imports into this one.
// This is useful when multiple generators need to output to the same file.
// The other generator's body is appended to this generator's body.
// Import paths are merged, with alias conflicts resolved automatically.
// All PackageRef in the merged generator will be updated to use the correct aliases.
func (g *Generator) Merge(other *Generator) *Generator {
	if other == nil {
		return g
	}

	// Build alias mapping: old alias -> new alias
	aliasMapping := make(map[string]string)

	// Merge imports and build mapping
	for importPath, pkg := range other.packages {
		oldAlias := pkg.alias

		if _, exists := g.packages[importPath]; !exists {
			// Package not yet registered, add it
			newPkg := g.P(importPath)
			// Record the alias mapping
			aliasMapping[oldAlias] = newPkg.alias
		} else {
			// Package already exists, use existing alias
			aliasMapping[oldAlias] = g.packages[importPath].alias
		}
	}

	// Update all PackageRef in other's body to point to this generator
	// and use the new aliases
	updatePackageRefs(other.g, g, aliasMapping)

	// Merge body - append other's body content to this generator
	g.g.Append(other.g)

	return g
}

// updatePackageRefs recursively updates all PackageRef in a node tree
// to use the new generator and alias mapping
func updatePackageRefs(node Node, newGen *Generator, aliasMapping map[string]string) {
	if node == nil {
		return
	}

	switch n := node.(type) {
	case *Group:
		for _, item := range n.items {
			updatePackageRefs(item, newGen, aliasMapping)
		}
	case *qualifiedIdent:
		// Update the PackageRef's generator and alias
		if n.pkg != nil {
			oldAlias := n.pkg.alias
			if newAlias, ok := aliasMapping[oldAlias]; ok {
				// Update to use the new generator's PackageRef
				if newPkg, exists := newGen.packages[n.pkg.importPath]; exists {
					n.pkg = newPkg
				} else {
					// If not found, at least update the alias
					n.pkg.gen = newGen
					n.pkg.alias = newAlias
				}
			}
		}
	case *sliceType:
		updatePackageRefs(n.elem, newGen, aliasMapping)
	case *ptrType:
		updatePackageRefs(n.elem, newGen, aliasMapping)
	case *mapType:
		updatePackageRefs(n.key, newGen, aliasMapping)
		updatePackageRefs(n.value, newGen, aliasMapping)
	case *chanType:
		updatePackageRefs(n.elem, newGen, aliasMapping)
	case *genericType:
		updatePackageRefs(n.base, newGen, aliasMapping)
		for _, arg := range n.args {
			updatePackageRefs(arg, newGen, aliasMapping)
		}
	case *ifunction:
		updatePackageRefs(n.receiver, newGen, aliasMapping)
		updatePackageRefs(n.parameters, newGen, aliasMapping)
		updatePackageRefs(n.results, newGen, aliasMapping)
		updatePackageRefs(n.body, newGen, aliasMapping)
		if n.call != nil {
			updatePackageRefs(n.call, newGen, aliasMapping)
		}
	case *istruct:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *iinterface:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *isignature:
		updatePackageRefs(n.parameters, newGen, aliasMapping)
		updatePackageRefs(n.results, newGen, aliasMapping)
		updatePackageRefs(n.comments, newGen, aliasMapping)
	case *ivar:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *iconst:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *iif:
		updatePackageRefs(n.judge, newGen, aliasMapping)
		updatePackageRefs(n.body, newGen, aliasMapping)
	case *ifor:
		updatePackageRefs(n.judge, newGen, aliasMapping)
		updatePackageRefs(n.body, newGen, aliasMapping)
	case *iswitch:
		updatePackageRefs(n.judge, newGen, aliasMapping)
		for _, c := range n.cases {
			updatePackageRefs(c.judge, newGen, aliasMapping)
			updatePackageRefs(c.body, newGen, aliasMapping)
		}
		if n.defaultCase != nil {
			updatePackageRefs(n.defaultCase.judge, newGen, aliasMapping)
			updatePackageRefs(n.defaultCase.body, newGen, aliasMapping)
		}
	case *ireturn:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *icall:
		updatePackageRefs(n.owner, newGen, aliasMapping)
		updatePackageRefs(n.items, newGen, aliasMapping)
		updatePackageRefs(n.calls, newGen, aliasMapping)
	case *ivalue:
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *islice:
		updatePackageRefs(n.elemType, newGen, aliasMapping)
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *iarray:
		updatePackageRefs(n.elemType, newGen, aliasMapping)
		updatePackageRefs(n.items, newGen, aliasMapping)
	case *itype:
		updatePackageRefs(n.item, newGen, aliasMapping)
	case *idefer:
		updatePackageRefs(n.body, newGen, aliasMapping)
	case *ifield:
		updatePackageRefs(n.name, newGen, aliasMapping)
		updatePackageRefs(n.typ, newGen, aliasMapping)
		updatePackageRefs(n.value, newGen, aliasMapping)
		// For other types like *istring, *lit, etc., no action needed
	}
}

// PackageName returns the current package name.
func (g *Generator) PackageName() string {
	return g.packageName
}
