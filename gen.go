package gg

import (
	"fmt"
	"io"
	"os"
	"sort"
)

// Generator is the main entry point for code generation.
// It manages packages, imports, and provides methods for generating Go code.
type Generator struct {
	g *group

	// Package management
	packageName     string                 // current package name (e.g., "main")
	packages        map[string]*PackageRef // importPath -> PackageRef
	aliasToPath     map[string]string      // alias -> importPath (for conflict detection)
	registeredPaths []string               // ordered list of import paths for deterministic output

	// Header comment (appears before package declaration)
	headerComment string
}

// New will create a new generator which hold the group reference.
func New() *Generator {
	return &Generator{
		g:           NewGroup(),
		packages:    make(map[string]*PackageRef),
		aliasToPath: make(map[string]string),
	}
}

// SetPackage sets the package name for the generated file.
func (g *Generator) SetPackage(name string) *Generator {
	g.packageName = name
	return g
}

// SetHeader sets a header comment that appears before the package declaration.
// Typically used for "Code generated by X. DO NOT EDIT." comments.
func (g *Generator) SetHeader(format string, args ...any) *Generator {
	g.headerComment = fmt.Sprintf(format, args...)
	return g
}

// P returns a PackageRef for the given import path.
// If the package was already registered, it returns the existing reference.
// Otherwise, it creates a new reference with an automatically resolved alias.
//
// Example:
//
//	types := gen.P("github.com/example/types")
//	other := gen.P("github.com/other/types")  // auto-aliased to "types2"
//	types.Type("User")  // => types.User
//	other.Type("User")  // => types2.User
func (g *Generator) P(importPath string) *PackageRef {
	// Return existing package reference if already registered
	if pkg, ok := g.packages[importPath]; ok {
		return pkg
	}

	// Build set of existing aliases
	existingAliases := make(map[string]bool)
	for alias := range g.aliasToPath {
		existingAliases[alias] = true
	}

	// Resolve alias (handles conflicts automatically)
	alias := resolvePackageAlias(importPath, existingAliases)

	// Create and register the package reference
	pkg := &PackageRef{
		importPath: importPath,
		alias:      alias,
		gen:        g,
	}
	g.packages[importPath] = pkg
	g.aliasToPath[alias] = importPath
	g.registeredPaths = append(g.registeredPaths, importPath)

	return pkg
}

// PAlias returns a PackageRef with a specific alias.
// Use this when you want to control the alias name explicitly.
//
// Example:
//
//	ctx := gen.PAlias("context", "ctx")
//	ctx.Type("Context")  // => ctx.Context
func (g *Generator) PAlias(importPath, alias string) *PackageRef {
	// Check if already registered with different alias
	if pkg, ok := g.packages[importPath]; ok {
		if pkg.alias != alias {
			// Update alias if different
			delete(g.aliasToPath, pkg.alias)
			pkg.alias = alias
			g.aliasToPath[alias] = importPath
		}
		return pkg
	}

	// Check for alias conflict
	if existingPath, ok := g.aliasToPath[alias]; ok && existingPath != importPath {
		panic(fmt.Sprintf("alias %q already used for package %q, cannot use for %q", alias, existingPath, importPath))
	}

	// Create and register the package reference
	pkg := &PackageRef{
		importPath: importPath,
		alias:      alias,
		gen:        g,
	}
	g.packages[importPath] = pkg
	g.aliasToPath[alias] = importPath
	g.registeredPaths = append(g.registeredPaths, importPath)

	return pkg
}

// Imports returns all registered import paths.
func (g *Generator) Imports() []string {
	return g.registeredPaths
}

// buildImportBlock creates the import block from registered packages.
func (g *Generator) buildImportBlock() *iimport {
	if len(g.packages) == 0 {
		return nil
	}

	imp := Import()

	// Sort imports for deterministic output
	paths := make([]string, 0, len(g.packages))
	for path := range g.packages {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	// Group imports: standard library first, then third-party
	var stdLib, thirdParty []string
	for _, p := range paths {
		if isStdLib(p) {
			stdLib = append(stdLib, p)
		} else {
			thirdParty = append(thirdParty, p)
		}
	}

	// Add standard library imports
	for _, p := range stdLib {
		pkg := g.packages[p]
		baseName := resolvePackageAlias(p, nil)
		if pkg.alias != baseName {
			imp.AddAlias(p, pkg.alias)
		} else {
			imp.AddPath(p)
		}
	}

	// Add blank line between groups if both exist
	if len(stdLib) > 0 && len(thirdParty) > 0 {
		imp.AddLine()
	}

	// Add third-party imports
	for _, p := range thirdParty {
		pkg := g.packages[p]
		baseName := resolvePackageAlias(p, nil)
		if pkg.alias != baseName {
			imp.AddAlias(p, pkg.alias)
		} else {
			imp.AddPath(p)
		}
	}

	return imp
}

// isStdLib checks if an import path is from the standard library.
func isStdLib(importPath string) bool {
	// Standard library packages don't contain dots in the first segment
	for i, r := range importPath {
		if r == '/' {
			return true // No dot before first slash = stdlib
		}
		if r == '.' {
			return false // Found dot before slash = third-party
		}
		if i > 20 {
			break // Safety limit
		}
	}
	return true // Short path without slash = likely stdlib
}

func (g *Generator) NewGroup() (ng *group) {
	ng = NewGroup()
	g.g.append(ng)
	return ng
}

// render writes the complete generated code including package declaration and imports.
func (g *Generator) render(w io.Writer) {
	// Write header comment (before package declaration)
	if g.headerComment != "" {
		writeStringF(w, "// %s\n", g.headerComment)
	}

	// Write package declaration
	if g.packageName != "" {
		writeStringF(w, "package %s\n\n", g.packageName)
	}

	// Write import block
	if imp := g.buildImportBlock(); imp != nil {
		imp.render(w)
		writeString(w, "\n\n")
	}

	// Write body
	g.g.render(w)
}

// Write will write the complete generated code into the given writer.
// This includes the package declaration and automatically generated imports.
func (g *Generator) Write(w io.Writer) {
	g.render(w)
}

// WriteFile will write the complete generated code into the given path.
func (g *Generator) WriteFile(path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create file %s: %s", path, err)
	}
	defer file.Close()
	g.render(file)
	return nil
}

// AppendFile will append the group after the given path.
// Note: This only appends the body, not package/imports.
func (g *Generator) AppendFile(path string) error {
	file, err := os.OpenFile(path, os.O_APPEND|os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("create file %s: %s", path, err)
	}
	defer file.Close()
	g.g.render(file)
	return nil
}

// String returns the complete generated code as a string.
func (g *Generator) String() string {
	buf := pool.Get()
	defer buf.Free()
	g.render(buf)
	return buf.String()
}

// Body returns the body group for adding code elements.
// This provides direct access to the internal group for adding functions, structs, etc.
func (g *Generator) Body() *group {
	return g.g
}

// Bytes returns the complete generated code as bytes.
func (g *Generator) Bytes() []byte {
	buf := pool.Get()
	defer buf.Free()
	g.render(buf)
	return buf.Bytes()
}
